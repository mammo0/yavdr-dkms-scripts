diff -r 7e47ba1d4ae8 linux/drivers/media/dvb/dvb-usb/dw2102.c
--- a/linux/drivers/media/dvb/dvb-usb/dw2102.c	Tue Mar 08 13:38:53 2011 +0200
+++ b/linux/drivers/media/dvb/dvb-usb/dw2102.c	Wed Mar 30 13:55:53 2011 +0200
@@ -853,6 +853,50 @@
 	return 0;
 }
 
+static int s6x0_identify_state(struct usb_device *dev,
+				 struct dvb_usb_device_properties *props,
+				 struct dvb_usb_device_description **desc,
+				 int *cold)
+{
+	struct usb_host_interface *alt;
+	struct usb_host_endpoint  *e;
+	u8 reset;
+
+	printk("%s\n",__func__);
+
+	*cold = 1;
+	alt = usb_altnum_to_altsetting(usb_ifnum_to_if(dev, 0), 0);
+	if (!alt)
+		return 0;
+
+	if (alt->desc.bNumEndpoints != 2)
+		return 0;
+
+	e = alt->endpoint + 1;
+	if (e->desc.wMaxPacketSize == 2){
+		*cold = 0;
+		reset = 1;
+		///*stop the CPU*/
+		dw210x_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1, DW210X_WRITE_MSG);
+		dw210x_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1, DW210X_WRITE_MSG);
+
+		/* restart the CPU */
+		reset = 0;
+		if (dw210x_op_rw(dev, 0xa0, 0x7f92, 0, &reset, 1,
+                        DW210X_WRITE_MSG) != 1) {
+		        err("could not restart the USB controller CPU.");
+			//        ret = -EINVAL;
+		}
+		if (dw210x_op_rw(dev, 0xa0, 0xe600, 0, &reset, 1,
+                        DW210X_WRITE_MSG) != 1) {
+		        err("could not restart the USB controller CPU.");
+			//       ret = -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static int su3000_identify_state(struct usb_device *udev,
 				 struct dvb_usb_device_properties *props,
 				 struct dvb_usb_device_description **desc,
@@ -1742,7 +1786,7 @@
 	.usb_ctrl = DEVICE_SPECIFIC,
 	.size_of_priv = sizeof(struct s6x0_state),
 	.firmware = "dvb-usb-s630.fw",
-	.no_reconnect = 1,
+        .identify_state = s6x0_identify_state,
 
 	.i2c_algo = &s6x0_i2c_algo,
 	.rc_key_map = ir_codes_tevii_table,
